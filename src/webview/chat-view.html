<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src #{cspSource} 'unsafe-inline'; script-src #{cspSource} 'unsafe-inline';">
    <title>Aider Chat</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            padding: 10px;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-sideBar-foreground);
        }

        #inputBox {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid var(--vscode-input-border);
            border-radius: 4px;
            font-size: 12px;
            box-sizing: border-box;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
        }

        #inputBox:focus {
            outline: 1px solid var(--vscode-focusBorder);
            border-color: var(--vscode-focusBorder);
        }

        #sendButton, #sendFileButton, #newChatButton {
            padding: 6px 12px;
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            font-size: 11px;
        }

        #sendButton:hover, #sendFileButton:hover, #newChatButton:hover {
            background-color: var(--vscode-button-hoverBackground);
        }

        #newChatButton {
            background-color: var(--vscode-button-secondaryBackground, #4a4a4a);
        }

        #newChatButton:hover {
            background-color: var(--vscode-button-secondaryHoverBackground, #555);
        }

        #terminal {
            height: 400px;
            width: 100%;
            padding: 8px;
            background-color: var(--vscode-terminal-background, #1e1e1e);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .input-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .button-container {
            display: flex;
            gap: 5px;
        }

        #modelSelect {
            margin-bottom: 10px;
            padding: 5px;
            width: 100%;
            font-size: 11px;
            background-color: var(--vscode-dropdown-background);
            color: var(--vscode-dropdown-foreground);
            border: 1px solid var(--vscode-dropdown-border);
            border-radius: 4px;
        }

        #modelSelect:focus {
            outline: 1px solid var(--vscode-focusBorder);
            border-color: var(--vscode-focusBorder);
        }

        /* Remove the old scrollbar styling since we're using xterm now */

        /* Interactive Prompt Overlay Styles */
        #promptOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .prompt-dialog {
            background-color: var(--vscode-quickInput-background);
            border: 1px solid var(--vscode-quickInput-border);
            border-radius: 6px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            color: var(--vscode-quickInput-foreground);
        }

        .prompt-dialog h3 {
            margin-top: 0;
            color: var(--vscode-textLink-foreground);
        }

        .prompt-dialog p {
            margin: 10px 0;
            white-space: pre-wrap;
        }

        .prompt-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .prompt-button {
            padding: 8px 16px;
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .prompt-button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }

        .prompt-button.secondary {
            background-color: var(--vscode-button-secondaryBackground, #4a4a4a);
        }

        .prompt-button.secondary:hover {
            background-color: var(--vscode-button-secondaryHoverBackground, #555);
        }
    </style>
</head>
<body>
    <div>
        <label for="modelSelect">Model:</label>
        <select id="modelSelect">
            #{modelOptions}
        </select>
        <button id="newChatButton">New Chat</button>
    </div>
    <div id="terminal"></div>
    <div class="input-container">
        <input id="inputBox" type="text" placeholder="Type your message to Aider...">
        <div class="button-container">
            <button id="sendButton">Send</button>
            <button id="sendFileButton">Send File</button>
        </div>
    </div>

    <!-- Interactive Prompt Overlay -->
    <div id="promptOverlay">
        <div class="prompt-dialog">
            <h3>Aider Needs Your Input</h3>
            <p id="promptText"></p>
            <div id="promptButtons" class="prompt-buttons">
                <!-- Buttons will be dynamically added here -->
            </div>
        </div>
    </div>

    <script>
        (function() {
            let terminal = null;
            let fitAddon = null;
            let retryCount = 0;
            const maxRetries = 5;

            // Debounce utility function
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Initialize xterm terminal with debounced retry
            function initializeTerminal() {
                try {
                    console.log('Checking for xterm modules...');
                    console.log('Terminal:', typeof window.Terminal);
                    console.log('FitAddon:', typeof window.FitAddon);
                    console.log('window.FitAddon object:', window.FitAddon);
                    console.log('All window properties with "Fit":', Object.keys(window).filter(key => key.includes('Fit')));

                    // Try different ways to access FitAddon
                    let FitAddonConstructor = null;
                    if (window.FitAddon) {
                        if (typeof window.FitAddon === 'function') {
                            FitAddonConstructor = window.FitAddon;
                        } else if (window.FitAddon.FitAddon && typeof window.FitAddon.FitAddon === 'function') {
                            FitAddonConstructor = window.FitAddon.FitAddon;
                        }
                    }

                    console.log('FitAddonConstructor:', FitAddonConstructor);

                    if (typeof window.Terminal !== 'undefined' && FitAddonConstructor) {
                        console.log('Creating xterm terminal...');

                        terminal = new window.Terminal({
                            cursorBlink: true,
                            fontSize: 12,
                            fontFamily: 'Courier New, monospace',
                            theme: {
                                background: '#1e1e1e',
                                foreground: '#cccccc',
                                cursor: '#ffffff'
                            },
                            // Enable full terminal functionality including CPR
                            disableStdin: false,
                            convertEol: true,
                            cols: 120,
                            rows: 30,
                            // Enhanced terminal options for full Aider compatibility
                            allowProposedApi: true,
                            cursorStyle: 'block',
                            scrollback: 10000,
                            tabStopWidth: 8,
                            // Enable CPR (Cursor Position Request) support for full terminal experience
                            windowsMode: false,
                            screenReaderMode: false
                        });

                        fitAddon = new FitAddonConstructor();
                        terminal.loadAddon(fitAddon);

                        // Try to load canvas addon for better rendering if available
                        if (window.CanvasAddon) {
                            try {
                                const canvasAddon = new window.CanvasAddon();
                                terminal.loadAddon(canvasAddon);
                                console.log('Canvas addon loaded for better rendering');
                            } catch (error) {
                                console.log('Canvas addon not available or failed to load:', error);
                            }
                        }

                        const terminalElement = document.getElementById('terminal');
                        terminal.open(terminalElement);

                        // Allow xterm.js to handle control sequences properly
                        // User input for chat goes through the input box
                        // Terminal control sequences are handled automatically

                        // Store terminal reference globally for CPR handling
                        window.currentTerminal = terminal;

                        // Enhanced CPR handling - the key insight is that xterm.js handles CPR automatically
                        // but we need to make sure the PTY gets a proper response when Aider sends CPR requests
                        
                        // Handle user input in terminal (keyboard input, not CPR responses)
                        terminal.onData((data) => {
                            console.log('ðŸ”„ Terminal user input (routing to PTY):', JSON.stringify(data));
                            
                            // Route user input to the backend PTY
                            vscode.postMessage({
                                command: 'terminalInput',
                                data: data
                            });
                        });

                        // Handle incoming data from PTY (including CPR requests from Aider)
                        // We need to intercept CPR requests and respond immediately
                        let cprBuffer = '';
                        const originalWrite = terminal.write.bind(terminal);
                        terminal.write = function(data) {
                            if (typeof data === 'string') {
                                cprBuffer += data;
                                
                                // Check for CPR request (\x1b[6n)
                                const cprMatch = cprBuffer.match(/\x1b\[6n/);
                                if (cprMatch) {
                                    console.log('ðŸŽ¯ CPR request detected from Aider!');
                                    
                                    // Generate immediate CPR response with current cursor position
                                    setTimeout(() => {
                                        const row = terminal.buffer.active.cursorY + 1;
                                        const col = terminal.buffer.active.cursorX + 1;
                                        const cprResponse = `\x1b[${row};${col}R`;
                                        
                                        console.log('ðŸ“¤ Sending CPR response:', JSON.stringify(cprResponse));
                                        
                                        // Send CPR response back to Aider via PTY
                                        vscode.postMessage({
                                            command: 'terminalInput',
                                            data: cprResponse,
                                            isCPR: true
                                        });
                                    }, 10); // Small delay to ensure terminal is ready
                                    
                                    // Clear the buffer after processing
                                    cprBuffer = '';
                                }
                                
                                // Keep only recent data in buffer (prevent memory leaks)
                                if (cprBuffer.length > 1000) {
                                    cprBuffer = cprBuffer.slice(-500);
                                }
                            }
                            
                            // Call original write function
                            return originalWrite(data);
                        };

                        // Initial fit and readiness signal
                        setTimeout(() => {
                            if (fitAddon) {
                                fitAddon.fit();
                                console.log('ðŸ“ Webview terminal fitted with dimensions:', terminal.cols, 'x', terminal.rows);
                                
                                // Send the "I'm ready" signal to the backend with dimensions
                                vscode.postMessage({
                                    command: 'webviewReady',
                                    cols: terminal.cols,
                                    rows: terminal.rows
                                });
                                console.log('âœ… Sent webviewReady signal to backend');
                            }
                        }, 100);

                        // Handle window resize events
                        window.addEventListener('resize', () => {
                            if (fitAddon && terminal) {
                                setTimeout(() => {
                                    fitAddon.fit();
                                    console.log('ðŸ“ Webview terminal resized to:', terminal.cols, 'x', terminal.rows);
                                    
                                    // Send new terminal size to backend
                                    vscode.postMessage({
                                        command: 'terminalResize',
                                        cols: terminal.cols,
                                        rows: terminal.rows
                                    });
                                    console.log('ðŸ“ Sent resize message to backend:', terminal.cols, 'x', terminal.rows);
                                }, 100);
                            }
                        });

                        // Debounced resize handler
                        const debouncedResize = debounce(() => {
                            if (fitAddon && terminal) {
                                fitAddon.fit();
                                console.log('Terminal resized to:', terminal.cols, 'x', terminal.rows);
                            }
                        }, 250);

                        window.addEventListener('resize', debouncedResize);

                        // Also trigger resize when the webview becomes visible
                        const observer = new MutationObserver(() => {
                            if (terminalElement.offsetWidth > 0 && terminalElement.offsetHeight > 0) {
                                debouncedResize();
                            }
                        });
                        observer.observe(terminalElement, { attributes: true, attributeFilter: ['style'] });

                        // Process any queued messages
                        if (window.messageQueue && window.messageQueue.length > 0) {
                            console.log('Processing', window.messageQueue.length, 'queued messages');
                            window.messageQueue.forEach(text => {
                                terminal.write(text);
                            });
                            window.messageQueue = [];
                        }

                        console.log('Xterm terminal initialized successfully');
                        retryCount = 0; // Reset retry count on success
                        return true;
                    } else {
                        console.warn('Xterm modules not available, retrying...');
                        scheduleRetry();
                        return false;
                    }
                } catch (error) {
                    console.error('Failed to initialize xterm terminal:', error);
                    scheduleRetry();
                    return false;
                }
            }

            // Debounced retry with exponential backoff
            function scheduleRetry() {
                retryCount++;
                if (retryCount <= maxRetries) {
                    const delay = Math.min(1000 * Math.pow(2, retryCount - 1), 5000); // Cap at 5 seconds
                    console.log(`Scheduling retry ${retryCount}/${maxRetries} in ${delay}ms`);
                    setTimeout(initializeTerminal, delay);
                } else {
                    console.error('Max retries reached for xterm initialization');
                }
            }

            // Acquire VS Code API once
            const vscode = acquireVsCodeApi();

            // Cache DOM elements
            const inputBox = document.getElementById('inputBox');
            const sendButton = document.getElementById('sendButton');
            const sendFileButton = document.getElementById('sendFileButton');
            const newChatButton = document.getElementById('newChatButton');
            const modelSelect = document.getElementById('modelSelect');

            // Input validation
            function sanitizeInput(input) {
                return input.trim().substring(0, 1000); // Limit length
            }

            function sendMessage() {
                const text = sanitizeInput(inputBox.value);
                if (text) {
                    const model = modelSelect.value;
                    vscode.postMessage({
                        command: 'sendToAider',
                        text: text,
                        model: model
                    });

                    inputBox.value = '';
                }
            }

            // Event listeners
            sendButton.addEventListener('click', sendMessage);

            inputBox.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            sendFileButton.addEventListener('click', () => {
                vscode.postMessage({ command: 'sendCurrentFile' });
            });

            newChatButton.addEventListener('click', () => {
                if (confirm('Start a new chat session? This will clear the current conversation.')) {
                    vscode.postMessage({ command: 'startNewChat' });
                }
            });

            // Interactive Prompt Handling
            function showInteractivePrompt(promptText, options = ['Yes', 'No']) {
                const promptTextElement = document.getElementById('promptText');
                const promptButtonsElement = document.getElementById('promptButtons');
                const promptOverlay = document.getElementById('promptOverlay');

                if (!promptTextElement || !promptButtonsElement || !promptOverlay) {
                    console.error('Prompt elements not found');
                    return;
                }

                // Set the prompt text
                promptTextElement.textContent = promptText;

                // Clear existing buttons
                promptButtonsElement.innerHTML = '';

                // Add buttons for each option
                options.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.textContent = option;
                    button.className = `prompt-button ${index === 1 ? 'secondary' : ''}`;
                    button.onclick = () => {
                        hideInteractivePrompt();
                        vscode.postMessage({
                            command: 'interactiveResponse',
                            response: option.toLowerCase(),
                            originalPrompt: promptText
                        });
                    };
                    promptButtonsElement.appendChild(button);
                });

                // Show the overlay
                promptOverlay.style.display = 'flex';
            }

            function hideInteractivePrompt() {
                const promptOverlay = document.getElementById('promptOverlay');
                if (promptOverlay) {
                    promptOverlay.style.display = 'none';
                }
            }

            // Message handling from extension
            window.addEventListener('message', event => {
                const message = event.data;
                if (message.command === 'updateConversation') {
                    if (terminal && terminal._core && fitAddon) {
                        try {
                            // Check if terminal is writable
                            if (terminal._core._bufferService) {
                                // CPR is handled by the backend, just write the text normally
                                const text = message.text;
                                if (text) {
                                    terminal.write(text);
                                }
                                
                                // Trigger a resize after writing content to ensure proper layout
                                setTimeout(() => {
                                    if (fitAddon) {
                                        fitAddon.fit();
                                    }
                                }, 50);
                                console.log('Wrote to xterm terminal');
                            } else {
                                console.warn('Terminal buffer service not available');
                            }
                        } catch (error) {
                            console.error('Error writing to terminal:', error);
                            console.log('Message was:', message.text);
                        }
                    } else {
                        console.warn('Terminal not ready for writing');
                    }
                } else if (message.command === 'clearTerminal') {
                    if (terminal && terminal._core) {
                        terminal.clear();
                        console.log('Terminal cleared');
                    }
                } else if (message.command === 'showInteractivePrompt') {
                    const options = message.options || ['Yes', 'No'];
                    showInteractivePrompt(message.promptText, options);
                } else if (message.command === 'hideInteractivePrompt') {
                    hideInteractivePrompt();
                }
            });

            // Initialize when ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeTerminal);
            } else {
                initializeTerminal();
            }
        })();
    </script>
</body>
</html>
